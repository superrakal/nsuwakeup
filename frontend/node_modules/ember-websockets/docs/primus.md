## Primus Support

### Setup

You need to load the client library before using this service.
This can be achieved by including the following
statement in your application template:

```
<script src="<YOUR_PRIMUS_SERVER_URL>/primus/primus.js"></script>
```

Note that the primus client library is generated by the server dynamically. This means
that if server-side options are changed (e.g. the underlying real-time framework
was changed from Engine.IO to SockJS) the client library will be altered to
reflect these changes.


### Usage

The Usage is identical to the websocket API. However, there are some minor
differences:
* The name of the service
* The protocol prefix of the primus server url (http/https instead of ws/wss)
* No argument will be passed to handler functions of ```open``` events
* The argument passed to handler functions of the ```message``` event will only
contain the received data / message and nothing else

```javascript
import Ember from 'ember';

export default Ember.Controller.extend({

  /*
  * 1) First step you need to do is inject the websocket service into your object. You
  * can inject the service into component, controllers, object, mixins, routes, and views.
  */
  socketService: Ember.inject.service('primus'),

  init: function() {
    this._super.apply(this, arguments);

    /*
    * 2) The next step you need to do is to create your actual websocket. Calling socketFor
    * will retrieve a cached websocket if one exists or in this case it
    * will create a new one for us.
    */
    var socket = this.get('socketService').socketFor('http://localhost:7000/');

    /*
    * 3) The final step is to define your event handlers. All event handlers
    * are added via the `on` method and take 3 arguments: event name, callback
    * function, and the context in which to invoke the callback. All 3 arguments
    * are required.
    */
    socket.on('open', this.myOpenHandler, this);
    socket.on('message', this.myMessageHandler, this);
    socket.on('close', function(event) {
      // anonymous functions work as well
    }, this);
  },

  myOpenHandler: function() {
    console.log('On open event has been called');
  },

  myMessageHandler: function(data) {
    console.log('Message: ' + data);
  },

  actions: {
    sendButtonPressed: function() {
      /*
      * If you need to retrieve your websocket from another function or method you can simply
      * get the cached version at no penalty
      */
      var socket = this.get('socketService').socketFor('ws://localhost:7000/');
      socket.send('Hello Websocket World');
    }
  }
});
```

### Detailed API Docs

### SocketFor

Example:

```javascript
var socket = this.get('socketService').socketFor('http://localhost:7000');
```

socketFor takes a 1 argument: **a url** and returns a primus client instance from its cache or a new primus client object if one was not found.

### On

Example:

```javascript
var socket = this.get('socketService').socketFor('http://localhost:7000/');

socket.on('connect', this.myOpenFunction, this);
```

on takes 3 arguments: **event type**, **callback function**, and **context**. Event type can be any string. Callback function will be invoked once that event types occurs. Context is used to set the context of the callback
function.

### Send

Example:

```javascript
var socket = this.get('socketService').socketFor('http://localhost:7000/');

socket.on('connect', function() {
  socket.send('My message');
}, this);
```

send takes 1 argument: **message**.

### CloseSocketFor

Example:

```javascript
var socket = this.get('socketService').socketFor('localhost:7000/');

socket.on('message', function() {
  this.get('socketService').closeSocketFor('localhost:7000/');
}, this);
```

closeSocketFor takes a single argument, **a url**, and closes the socket.io connection. It will also remove it from the cache. In normal cases you would not have to call this method.
