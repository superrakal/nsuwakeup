{"version":3,"sources":["active-model-adapter.js","active-model-adapter/active-model-adapter.js","active-model-adapter/active-model-serializer.js","active-model-adapter/index.js","ember-cli-content-security-policy.js"],"sourcesContent":["define('active-model-adapter', ['active-model-adapter/index', 'ember', 'exports'], function(__index__, __Ember__, __exports__) {\n  'use strict';\n  var keys = Object.keys || __Ember__['default'].keys;\n  var forEach = Array.prototype.forEach && function(array, cb) {\n    array.forEach(cb);\n  } || __Ember__['default'].EnumerableUtils.forEach;\n\n  forEach(keys(__index__), (function(key) {\n    __exports__[key] = __index__[key];\n  }));\n});\n","define('active-model-adapter/active-model-adapter', ['exports', 'ember', 'ember-data'], function (exports, Ember, DS) {\n\n  'use strict';\n\n  var InvalidError = DS['default'].InvalidError;\n  var errorsHashToArray = DS['default'].errorsHashToArray;\n  var RESTAdapter = DS['default'].RESTAdapter;\n  var _Ember$String = Ember['default'].String;\n  var pluralize = _Ember$String.pluralize;\n  var decamelize = _Ember$String.decamelize;\n  var underscore = _Ember$String.underscore;\n\n  /**\n    @module ember-data\n  */\n\n  /**\n    The ActiveModelAdapter is a subclass of the RESTAdapter designed to integrate\n    with a JSON API that uses an underscored naming convention instead of camelCasing.\n    It has been designed to work out of the box with the\n    [active\\_model\\_serializers](http://github.com/rails-api/active_model_serializers)\n    Ruby gem. This Adapter expects specific settings using ActiveModel::Serializers,\n    `embed :ids, embed_in_root: true` which sideloads the records.\n\n    This adapter extends the DS.RESTAdapter by making consistent use of the camelization,\n    decamelization and pluralization methods to normalize the serialized JSON into a\n    format that is compatible with a conventional Rails backend and Ember Data.\n\n    ## JSON Structure\n\n    The ActiveModelAdapter expects the JSON returned from your server to follow\n    the REST adapter conventions substituting underscored keys for camelcased ones.\n\n    Unlike the DS.RESTAdapter, async relationship keys must be the singular form\n    of the relationship name, followed by \"_id\" for DS.belongsTo relationships,\n    or \"_ids\" for DS.hasMany relationships.\n\n    ### Conventional Names\n\n    Attribute names in your JSON payload should be the underscored versions of\n    the attributes in your Ember.js models.\n\n    For example, if you have a `Person` model:\n\n    ```js\n    App.FamousPerson = DS.Model.extend({\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string'),\n      occupation: DS.attr('string')\n    });\n    ```\n\n    The JSON returned should look like this:\n\n    ```js\n    {\n      \"famous_person\": {\n        \"id\": 1,\n        \"first_name\": \"Barack\",\n        \"last_name\": \"Obama\",\n        \"occupation\": \"President\"\n      }\n    }\n    ```\n\n    Let's imagine that `Occupation` is just another model:\n\n    ```js\n    App.Person = DS.Model.extend({\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string'),\n      occupation: DS.belongsTo('occupation')\n    });\n\n    App.Occupation = DS.Model.extend({\n      name: DS.attr('string'),\n      salary: DS.attr('number'),\n      people: DS.hasMany('person')\n    });\n    ```\n\n    The JSON needed to avoid extra server calls, should look like this:\n\n    ```js\n    {\n      \"people\": [{\n        \"id\": 1,\n        \"first_name\": \"Barack\",\n        \"last_name\": \"Obama\",\n        \"occupation_id\": 1\n      }],\n\n      \"occupations\": [{\n        \"id\": 1,\n        \"name\": \"President\",\n        \"salary\": 100000,\n        \"person_ids\": [1]\n      }]\n    }\n    ```\n\n    @class ActiveModelAdapter\n    @constructor\n    @namespace DS\n    @extends DS.RESTAdapter\n  **/\n\n  var ActiveModelAdapter = RESTAdapter.extend({\n    defaultSerializer: '-active-model',\n    /**\n      The ActiveModelAdapter overrides the `pathForType` method to build\n      underscored URLs by decamelizing and pluralizing the object type name.\n       ```js\n        this.pathForType(\"famousPerson\");\n        //=> \"famous_people\"\n      ```\n       @method pathForType\n      @param {String} modelName\n      @return String\n    */\n    pathForType: function pathForType(modelName) {\n      var decamelized = decamelize(modelName);\n      var underscored = underscore(decamelized);\n      return pluralize(underscored);\n    },\n\n    /**\n      The ActiveModelAdapter overrides the `handleResponse` method\n      to format errors passed to a DS.InvalidError for all\n      422 Unprocessable Entity responses.\n       A 422 HTTP response from the server generally implies that the request\n      was well formed but the API was unable to process it because the\n      content was not semantically correct or meaningful per the API.\n       For more information on 422 HTTP Error code see 11.2 WebDAV RFC 4918\n      https://tools.ietf.org/html/rfc4918#section-11.2\n       @method ajaxError\n      @param {Object} jqXHR\n      @return error\n    */\n    handleResponse: function handleResponse(status, headers, payload) {\n      if (this.isInvalid(status, headers, payload)) {\n        var errors = errorsHashToArray(payload.errors);\n\n        return new InvalidError(errors);\n      } else {\n        return this._super.apply(this, arguments);\n      }\n    }\n  });\n\n  exports['default'] = ActiveModelAdapter;\n\n});","define('active-model-adapter/active-model-serializer', ['exports', 'ember-data', 'ember'], function (exports, DS, Ember) {\n\n  'use strict';\n\n  var _Ember$String = Ember['default'].String;\n  var singularize = _Ember$String.singularize;\n  var classify = _Ember$String.classify;\n  var decamelize = _Ember$String.decamelize;\n  var camelize = _Ember$String.camelize;\n  var underscore = _Ember$String.underscore;\n  var RESTSerializer = DS['default'].RESTSerializer;\n  var normalizeModelName = DS['default'].normalizeModelName;\n\n  /**\n    The ActiveModelSerializer is a subclass of the RESTSerializer designed to integrate\n    with a JSON API that uses an underscored naming convention instead of camelCasing.\n    It has been designed to work out of the box with the\n    [active\\_model\\_serializers](http://github.com/rails-api/active_model_serializers)\n    Ruby gem. This Serializer expects specific settings using ActiveModel::Serializers,\n    `embed :ids, embed_in_root: true` which sideloads the records.\n\n    This serializer extends the DS.RESTSerializer by making consistent\n    use of the camelization, decamelization and pluralization methods to\n    normalize the serialized JSON into a format that is compatible with\n    a conventional Rails backend and Ember Data.\n\n    ## JSON Structure\n\n    The ActiveModelSerializer expects the JSON returned from your server\n    to follow the REST adapter conventions substituting underscored keys\n    for camelcased ones.\n\n    ### Conventional Names\n\n    Attribute names in your JSON payload should be the underscored versions of\n    the attributes in your Ember.js models.\n\n    For example, if you have a `Person` model:\n\n    ```js\n    App.FamousPerson = DS.Model.extend({\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string'),\n      occupation: DS.attr('string')\n    });\n    ```\n\n    The JSON returned should look like this:\n\n    ```js\n    {\n      \"famous_person\": {\n        \"id\": 1,\n        \"first_name\": \"Barack\",\n        \"last_name\": \"Obama\",\n        \"occupation\": \"President\"\n      }\n    }\n    ```\n\n    Let's imagine that `Occupation` is just another model:\n\n    ```js\n    App.Person = DS.Model.extend({\n      firstName: DS.attr('string'),\n      lastName: DS.attr('string'),\n      occupation: DS.belongsTo('occupation')\n    });\n\n    App.Occupation = DS.Model.extend({\n      name: DS.attr('string'),\n      salary: DS.attr('number'),\n      people: DS.hasMany('person')\n    });\n    ```\n\n    The JSON needed to avoid extra server calls, should look like this:\n\n    ```js\n    {\n      \"people\": [{\n        \"id\": 1,\n        \"first_name\": \"Barack\",\n        \"last_name\": \"Obama\",\n        \"occupation_id\": 1\n      }],\n\n      \"occupations\": [{\n        \"id\": 1,\n        \"name\": \"President\",\n        \"salary\": 100000,\n        \"person_ids\": [1]\n      }]\n    }\n    ```\n\n    @class ActiveModelSerializer\n    @namespace DS\n    @extends DS.RESTSerializer\n  */\n  var ActiveModelSerializer = RESTSerializer.extend({\n    // SERIALIZE\n\n    /**\n      Converts camelCased attributes to underscored when serializing.\n       @method keyForAttribute\n      @param {String} attribute\n      @return String\n    */\n    keyForAttribute: function keyForAttribute(attr) {\n      return decamelize(attr);\n    },\n\n    /**\n      Underscores relationship names and appends \"_id\" or \"_ids\" when serializing\n      relationship keys.\n       @method keyForRelationship\n      @param {String} relationshipModelName\n      @param {String} kind\n      @return String\n    */\n    keyForRelationship: function keyForRelationship(relationshipModelName, kind) {\n      var key = decamelize(relationshipModelName);\n      if (kind === \"belongsTo\") {\n        return key + \"_id\";\n      } else if (kind === \"hasMany\") {\n        return singularize(key) + \"_ids\";\n      } else {\n        return key;\n      }\n    },\n\n    /**\n     `keyForLink` can be used to define a custom key when deserializing link\n     properties. The `ActiveModelSerializer` camelizes link keys by default.\n      @method keyForLink\n     @param {String} key\n     @param {String} kind `belongsTo` or `hasMany`\n     @return {String} normalized key\n    */\n    keyForLink: function keyForLink(key, relationshipKind) {\n      return camelize(key);\n    },\n\n    /*\n      Does not serialize hasMany relationships by default.\n    */\n    serializeHasMany: function serializeHasMany() {},\n\n    /**\n     Underscores the JSON root keys when serializing.\n       @method payloadKeyFromModelName\n      @param {String} modelName\n      @return {String}\n    */\n    payloadKeyFromModelName: function payloadKeyFromModelName(modelName) {\n      return underscore(decamelize(modelName));\n    },\n\n    /**\n      Serializes a polymorphic type as a fully capitalized model name.\n       @method serializePolymorphicType\n      @param {DS.Snapshot} snapshot\n      @param {Object} json\n      @param {Object} relationship\n    */\n    serializePolymorphicType: function serializePolymorphicType(snapshot, json, relationship) {\n      var key = relationship.key;\n      var belongsTo = snapshot.belongsTo(key);\n      var jsonKey = underscore(key + \"_type\");\n\n      if (Ember['default'].isNone(belongsTo)) {\n        json[jsonKey] = null;\n      } else {\n        json[jsonKey] = classify(belongsTo.modelName).replace('/', '::');\n      }\n    },\n\n    /**\n      Add extra step to `DS.RESTSerializer.normalize` so links are normalized.\n       If your payload looks like:\n       ```js\n      {\n        \"post\": {\n          \"id\": 1,\n          \"title\": \"Rails is omakase\",\n          \"links\": { \"flagged_comments\": \"api/comments/flagged\" }\n        }\n      }\n      ```\n       The normalized version would look like this\n       ```js\n      {\n        \"post\": {\n          \"id\": 1,\n          \"title\": \"Rails is omakase\",\n          \"links\": { \"flaggedComments\": \"api/comments/flagged\" }\n        }\n      }\n      ```\n       @method normalize\n      @param {subclass of DS.Model} typeClass\n      @param {Object} hash\n      @param {String} prop\n      @return Object\n    */\n    normalize: function normalize(typeClass, hash, prop) {\n      this.normalizeLinks(hash);\n      return this._super(typeClass, hash, prop);\n    },\n\n    /**\n      Convert `snake_cased` links  to `camelCase`\n       @method normalizeLinks\n      @param {Object} data\n    */\n\n    normalizeLinks: function normalizeLinks(data) {\n      if (data.links) {\n        var links = data.links;\n\n        for (var link in links) {\n          var camelizedLink = camelize(link);\n\n          if (camelizedLink !== link) {\n            links[camelizedLink] = links[link];\n            delete links[link];\n          }\n        }\n      }\n    },\n\n    extractRelationships: function extractRelationships(modelClass, resourceHash) {\n      modelClass.eachRelationship(function (key, relationshipMeta) {\n        var relationshipKey = this.keyForRelationship(key, relationshipMeta.kind, \"deserialize\");\n\n        // prefer the format the AMS gem expects, e.g.:\n        // relationship: {id: id, type: type}\n        if (relationshipMeta.options.polymorphic) {\n          extractPolymorphicRelationships(key, relationshipMeta, resourceHash, relationshipKey);\n        }\n        // If the preferred format is not found, use {relationship_name_id, relationship_name_type}\n        if (resourceHash.hasOwnProperty(relationshipKey) && typeof resourceHash[relationshipKey] !== 'object') {\n          var polymorphicTypeKey = this.keyForRelationship(key) + '_type';\n          if (resourceHash[polymorphicTypeKey] && relationshipMeta.options.polymorphic) {\n            var id = resourceHash[relationshipKey];\n            var type = resourceHash[polymorphicTypeKey];\n            delete resourceHash[polymorphicTypeKey];\n            delete resourceHash[relationshipKey];\n            resourceHash[relationshipKey] = { id: id, type: type };\n          }\n        }\n      }, this);\n      return this._super.apply(this, arguments);\n    },\n\n    modelNameFromPayloadKey: function modelNameFromPayloadKey(key) {\n      var convertedFromRubyModule = singularize(key.replace('::', '/'));\n      return normalizeModelName(convertedFromRubyModule);\n    }\n  });\n\n  function extractPolymorphicRelationships(key, relationshipMeta, resourceHash, relationshipKey) {\n    var polymorphicKey = decamelize(key);\n    var hash = resourceHash[polymorphicKey];\n    if (hash !== null && typeof hash === 'object') {\n      resourceHash[relationshipKey] = hash;\n    }\n  }\n\n  exports['default'] = ActiveModelSerializer;\n\n});","define('active-model-adapter/index', ['exports', 'active-model-adapter/active-model-adapter', 'active-model-adapter/active-model-serializer'], function (exports, ActiveModelAdapter, ActiveModelSerializer) {\n\n\t'use strict';\n\n\texports['default'] = ActiveModelAdapter['default'];\n\n\texports.ActiveModelAdapter = ActiveModelAdapter['default'];\n\texports.ActiveModelSerializer = ActiveModelSerializer['default'];\n\n});","define('ember-cli-content-security-policy', ['ember-cli-content-security-policy/index', 'ember', 'exports'], function(__index__, __Ember__, __exports__) {\n  'use strict';\n  var keys = Object.keys || __Ember__['default'].keys;\n  var forEach = Array.prototype.forEach && function(array, cb) {\n    array.forEach(cb);\n  } || __Ember__['default'].EnumerableUtils.forEach;\n\n  forEach(keys(__index__), (function(key) {\n    __exports__[key] = __index__[key];\n  }));\n});\n"],"names":[],"mappings":"AAAA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACVA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACvJA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;AC/QA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;;ACRA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;AACA;","file":"addons.js"}